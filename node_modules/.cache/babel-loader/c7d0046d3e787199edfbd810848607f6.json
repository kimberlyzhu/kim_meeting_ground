{"ast":null,"code":"import { useRef, useState, useCallback, useEffect, createContext, useContext, createElement } from 'react';\n\nvar isCheckBoxInput = type => type === 'checkbox';\n\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit'\n};\nconst RADIO_INPUT = 'radio';\nconst REQUIRED_ATTRIBUTE = 'required';\nconst PATTERN_ATTRIBUTE = 'pattern';\nconst UNDEFINED = 'undefined';\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\n\nfunction attachEventListeners({\n  field,\n  validateAndStateUpdate,\n  isRadio,\n  isOnBlur,\n  isReValidateOnBlur\n}) {\n  const {\n    ref\n  } = field;\n  if (!ref.addEventListener) return;\n  ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? EVENTS.CHANGE : EVENTS.INPUT, validateAndStateUpdate);\n  if (isOnBlur || isReValidateOnBlur) ref.addEventListener(EVENTS.BLUR, validateAndStateUpdate);\n}\n\nvar isUndefined = val => val === undefined;\n\nvar isNullOrUndefined = value => value === null || isUndefined(value);\n\nvar isArray = value => Array.isArray(value);\n\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && typeof value === 'object';\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\nfunction isIndex(value) {\n  return reIsUint.test(value) && value > -1;\n}\n\nfunction isKey(value) {\n  if (isArray(value)) return false;\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value);\n}\n\nconst stringToPath = string => {\n  const result = [];\n  string.replace(rePropName, (match, number, quote, string) => {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : isIndex(tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar combineFieldValues = data => Object.entries(data).reduce((previous, [key, value]) => {\n  if (!!key.match(/\\[.+\\]/gi) || key.indexOf('.') > 0) {\n    set(previous, key, value);\n    return previous;\n  }\n\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (!ref.removeEventListener) return;\n  ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n  ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n  ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n};\n\nvar isRadioInput = type => type === RADIO_INPUT;\n\nfunction isDetached(element) {\n  if (!element) return true;\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) return false;\n  return isDetached(element.parentNode);\n}\n\nfunction findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate = () => {}, field, forceDelete = false) {\n  if (!field) return;\n  const {\n    ref,\n    mutationWatcher,\n    options\n  } = field;\n  if (!ref || !ref.type) return;\n  const {\n    name,\n    type\n  } = ref;\n\n  if (isRadioInput(type) && options) {\n    options.forEach(({\n      ref\n    }, index) => {\n      if (options[index] && isDetached(ref) || forceDelete) {\n        removeAllEventListeners(options[index], validateWithStateUpdate);\n        (options[index].mutationWatcher || {\n          disconnect: () => {}\n        }).disconnect();\n        options.splice(index, 1);\n      }\n    });\n    if (!options.length) delete fields[name];\n  } else if (isDetached(ref) || forceDelete) {\n    removeAllEventListeners(ref, validateWithStateUpdate);\n    if (mutationWatcher) mutationWatcher.disconnect();\n    delete fields[name];\n  }\n}\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, {\n  ref: {\n    checked,\n    value\n  }\n}) => checked ? {\n  isValid: true,\n  value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isMultipleSelect = type => type === 'select-multiple';\n\nfunction getFieldValue(fields, ref) {\n  const {\n    type,\n    name,\n    options,\n    checked,\n    value,\n    files\n  } = ref;\n\n  if (type === 'file') {\n    return files;\n  }\n\n  if (isRadioInput(type)) {\n    const field = fields[name];\n    return field ? getRadioValue(field.options).value : '';\n  }\n\n  if (isMultipleSelect(type)) return getMultipleSelectValue(options);\n\n  if (isCheckBoxInput(type)) {\n    if (checked) {\n      return ref.attributes && ref.attributes.value ? isUndefined(value) || value === '' ? true : value : true;\n    }\n\n    return false;\n  }\n\n  return value;\n}\n\nvar getFieldsValues = fields => Object.values(fields).reduce((previous, {\n  ref,\n  ref: {\n    name\n  }\n}) => Object.assign(Object.assign({}, previous), {\n  [name]: getFieldValue(fields, ref)\n}), {});\n\nvar isEmptyObject = value => isObject(value) && Object.keys(value).length === 0;\n\nvar isSameError = (error, type, message) => isObject(error) && error.type === type && error.message === message; // TODO: improve the types in this file\n\n\nfunction shouldUpdateWithError({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  if (validFields.has(name) && isEmptyObject(error) || errors[name] && errors[name].isManual) {\n    return false;\n  }\n\n  if (fieldsWithValidation.has(name) && !validFields.has(name) && isEmptyObject(error) || isEmptyObject(errors) && !isEmptyObject(error) || isEmptyObject(error) && errors[name] || !errors[name]) {\n    return true;\n  }\n\n  return errors[name] && error[name] && !isSameError(errors[name], error[name].type, error[name].message);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nvar getValueAndMessage = validationData => ({\n  value: isObject(validationData) && !isRegex(validationData) ? validationData.value : validationData,\n  message: isObject(validationData) && !isRegex(validationData) ? validationData.message : ''\n});\n\nvar isString = value => typeof value === 'string';\n\nvar displayNativeError = (nativeValidation, ref, message) => {\n  if (nativeValidation && isString(message)) ref.setCustomValidity(message);\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction getValidateFunctionErrorObject(result, ref, nativeError, type = 'validate') {\n  const isStringValue = isString(result);\n\n  if (isStringValue || isBoolean(result) && !result) {\n    const message = isStringValue ? result : '';\n    const error = {\n      type,\n      message,\n      ref\n    };\n    nativeError(message);\n    return error;\n  }\n\n  return;\n}\n\nvar validateField = async ({\n  ref,\n  ref: {\n    type,\n    value,\n    name,\n    checked\n  },\n  options,\n  required,\n  maxLength,\n  minLength,\n  min,\n  max,\n  pattern,\n  validate\n}, fields, nativeValidation) => {\n  const error = {};\n  const isRadio = isRadioInput(type);\n  const isCheckBox = isCheckBoxInput(type);\n  const nativeError = displayNativeError.bind(null, nativeValidation, ref);\n  const typedName = name;\n\n  if (required && (isCheckBox && !checked || !isCheckBox && !isRadio && value === '' || isRadio && !getRadioValue(fields[typedName].options).isValid || !type && isNullOrUndefined(value))) {\n    error[typedName] = {\n      type: REQUIRED_ATTRIBUTE,\n      message: isString(required) ? required : '',\n      ref: isRadio ? fields[typedName].options[0].ref : ref\n    };\n    nativeError(required);\n    return error;\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const {\n      value: maxValue,\n      message: maxMessage\n    } = getValueAndMessage(max);\n    const {\n      value: minValue,\n      message: minMessage\n    } = getValueAndMessage(min);\n\n    if (type === 'number') {\n      const valueNumber = parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) exceedMax = valueNumber > maxValue;\n      if (!isNullOrUndefined(minValue)) exceedMin = valueNumber < minValue;\n    } else {\n      if (isString(maxValue)) exceedMax = new Date(value) > new Date(maxValue);\n      if (isString(minValue)) exceedMin = new Date(value) < new Date(minValue);\n    }\n\n    if (exceedMax || exceedMin) {\n      const message = exceedMax ? maxMessage : minMessage;\n      error[typedName] = {\n        type: exceedMax ? 'max' : 'min',\n        message,\n        ref\n      };\n      nativeError(message);\n      return error;\n    }\n  }\n\n  if ((maxLength || minLength) && isString(value)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax = maxLength && inputLength > maxLengthValue;\n    const exceedMin = minLength && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      const message = exceedMax ? maxLengthMessage : minLengthMessage;\n      error[typedName] = {\n        type: exceedMax ? 'maxLength' : 'minLength',\n        message,\n        ref\n      };\n      nativeError(message);\n      return error;\n    }\n  }\n\n  if (pattern) {\n    const {\n      value: patternValue,\n      message: patternMessage\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[typedName] = {\n        type: PATTERN_ATTRIBUTE,\n        message: patternMessage,\n        ref\n      };\n      nativeError(patternMessage);\n      return error;\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fields, ref);\n    const validateRef = isRadio && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const errorObject = getValidateFunctionErrorObject(result, validateRef, nativeError);\n\n      if (errorObject) {\n        error[typedName] = errorObject;\n        return error;\n      }\n    } else if (isObject(validate)) {\n      const validationResult = await new Promise(resolve => {\n        const values = Object.entries(validate);\n        values.reduce(async (previous, [key, validate], index) => {\n          const lastChild = values.length - 1 === index;\n\n          if (isFunction(validate)) {\n            const result = await validate(fieldValue);\n            const errorObject = getValidateFunctionErrorObject(result, validateRef, nativeError, key);\n\n            if (errorObject) {\n              return lastChild ? resolve(errorObject) : errorObject;\n            }\n          }\n\n          return lastChild ? resolve(previous) : previous;\n        }, {});\n      });\n\n      if (!isEmptyObject(validationResult)) {\n        error[typedName] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n        return error;\n      }\n    }\n  }\n\n  if (nativeValidation) ref.setCustomValidity('');\n  return error;\n}; // TODO: Fix these types\n\n\nconst parseErrorSchema = error => error.inner.length ? error.inner.reduce((previous, {\n  path,\n  message,\n  type\n}) => Object.assign(Object.assign({}, previous), {\n  [path]: {\n    message,\n    ref: {},\n    type\n  }\n}), {}) : {\n  [error.path]: {\n    message: error.message,\n    ref: {},\n    type: error.type\n  }\n};\n\nasync function validateWithSchema(validationSchema, validationSchemaOption, data) {\n  try {\n    return {\n      result: await validationSchema.validate(data, validationSchemaOption),\n      fieldErrors: {}\n    };\n  } catch (e) {\n    return {\n      result: {},\n      fieldErrors: parseErrorSchema(e)\n    };\n  }\n}\n\nfunction attachNativeValidation(ref, rules) {\n  Object.entries(rules).forEach(([key, value]) => {\n    if (key === PATTERN_ATTRIBUTE && isRegex(value)) {\n      ref[key] = value.source;\n    } else {\n      ref[key] = key === REQUIRED_ATTRIBUTE ? true : value;\n    }\n  });\n}\n\nvar get = (obj, path, defaultValue) => {\n  const result = String.prototype.split.call(path, /[,[\\].]+?/).filter(Boolean).reduce((res, key) => res !== null && res !== undefined ? res[key] : res, obj);\n  return result === undefined || result === obj ? defaultValue : result;\n};\n\nvar getDefaultValue = (defaultValues, name, defaultValue) => isUndefined(defaultValues[name]) ? get(defaultValues, name, defaultValue) : defaultValues[name];\n\nfunction flatArray(list) {\n  return list.reduce((a, b) => a.concat(isArray(b) ? flatArray(b) : b), []);\n}\n\nconst getPath = (path, values) => isArray(values) ? values.map((item, index) => {\n  const pathWithIndex = `${path}[${index}]`;\n\n  if (isArray(item)) {\n    return getPath(pathWithIndex, item);\n  } else if (isObject(item)) {\n    return Object.entries(item).map(([key, objectValue]) => isString(objectValue) ? `${pathWithIndex}.${key}` : getPath(`${pathWithIndex}.${key}`, objectValue));\n  }\n\n  return pathWithIndex;\n}) : Object.entries(values).map(([key, objectValue]) => isString(objectValue) ? `${path}.${key}` : getPath(path, objectValue));\n\nvar getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields) => {\n  if (isNullOrUndefined(fieldValues) || isEmptyObject(fieldValues)) return undefined;\n\n  if (!isUndefined(fieldValues[fieldName])) {\n    watchFields[fieldName] = true;\n    return fieldValues[fieldName];\n  }\n\n  const values = get(combineFieldValues(fieldValues), fieldName);\n\n  if (!isUndefined(values)) {\n    const result = getPath$1(fieldName, values);\n\n    if (isArray(result)) {\n      result.forEach(name => {\n        watchFields[name] = true;\n      });\n    }\n  }\n\n  return values;\n};\n\nvar omitValidFields = (errorFields, validFieldNames) => Object.entries(errorFields).reduce((previous, [name, error]) => validFieldNames.some(validFieldName => validFieldName === name) ? previous : Object.assign(Object.assign({}, previous), {\n  [name]: error\n}), {});\n\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange\n});\n\nvar pickErrors = (errors, pickList) => Object.entries(errors).reduce((previous, [key, error]) => Object.assign(Object.assign({}, previous), pickList.includes(key) ? {\n  [key]: error\n} : null), {});\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  validationSchema,\n  defaultValues = {},\n  validationFields,\n  nativeValidation,\n  submitFocusError = true,\n  validationSchemaOption = {\n    abortEarly: false\n  }\n} = {}) {\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const schemaErrorsRef = useRef({});\n  const touchedFieldsRef = useRef(new Set());\n  const watchFieldsRef = useRef({});\n  const dirtyFieldsRef = useRef(new Set());\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const defaultValuesRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const isSchemaValidateTriggeredRef = useRef(false);\n  const validationFieldsRef = useRef(validationFields);\n  const validateAndUpdateStateRef = useRef();\n  const [, render] = useState();\n  const {\n    isOnBlur,\n    isOnSubmit\n  } = useRef(modeChecker(mode)).current;\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnSubmit: isReValidateOnSubmit\n  } = useRef(modeChecker(reValidateMode)).current;\n  const validationSchemaOptionRef = useRef(validationSchemaOption);\n  validationFieldsRef.current = validationFields;\n\n  const combineErrorsRef = data => Object.assign(Object.assign({}, errorsRef.current), data);\n\n  const renderBaseOnError = useCallback((name, error, shouldRender = true) => {\n    if (isEmptyObject(error)) {\n      delete errorsRef.current[name];\n      if (fieldsWithValidationRef.current.has(name) || validationSchema) validFieldsRef.current.add(name);\n    } else {\n      validFieldsRef.current.delete(name);\n    }\n\n    if (shouldRender) render({});\n  }, [validationSchema]);\n\n  const setFieldValue = (name, rawValue) => {\n    const field = fieldsRef.current[name];\n    if (!field) return false;\n    const ref = field.ref;\n    const {\n      type\n    } = ref;\n    const options = field.options;\n    const value = typeof document !== UNDEFINED && typeof window !== UNDEFINED && !isUndefined(window.HTMLElement) && ref instanceof window.HTMLElement && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(type) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isMultipleSelect(type)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else {\n      ref[isCheckBoxInput(type) ? 'checked' : 'value'] = value;\n    }\n\n    return type;\n  };\n\n  const setDirty = name => {\n    if (!fieldsRef.current[name]) return false;\n    const isDirty = defaultValuesRef.current[name] !== getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\n    const isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;\n\n    if (isDirty) {\n      dirtyFieldsRef.current.add(name);\n    } else {\n      dirtyFieldsRef.current.delete(name);\n    }\n\n    isDirtyRef.current = !!dirtyFieldsRef.current.size;\n    return isDirtyChanged;\n  };\n\n  const setValueInternal = useCallback((name, value) => {\n    const shouldRender = setFieldValue(name, value);\n\n    if (setDirty(name) || shouldRender || !touchedFieldsRef.current.has(name)) {\n      touchedFieldsRef.current.add(name);\n      render({});\n    }\n  }, []);\n  const executeValidation = useCallback(async ({\n    name,\n    value\n  }, shouldRender = true) => {\n    const field = fieldsRef.current[name];\n    if (!field) return false;\n    if (!isUndefined(value)) setValueInternal(name, value);\n    const error = await validateField(field, fieldsRef.current);\n    errorsRef.current = combineErrorsRef(error);\n    renderBaseOnError(name, error, shouldRender);\n    return isEmptyObject(error);\n  }, [renderBaseOnError, setValueInternal]);\n  const validateWithSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOptionRef.current), [validationSchema]);\n  const executeSchemaValidation = useCallback(async payload => {\n    const {\n      fieldErrors\n    } = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fieldsRef.current)));\n    const names = isArray(payload) ? payload.map(({\n      name\n    }) => name) : [payload.name];\n    const validFieldNames = names.filter(name => !fieldErrors[name]);\n    schemaErrorsRef.current = fieldErrors;\n    isSchemaValidateTriggeredRef.current = true;\n    errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors).filter(([key]) => names.includes(key)).reduce((previous, [name, error]) => Object.assign(Object.assign({}, previous), {\n      [name]: error\n    }), {})), validFieldNames);\n    render({});\n    return isEmptyObject(errorsRef.current);\n  }, [validateWithSchemaCurry]);\n  const triggerValidation = useCallback(async (payload, shouldRender) => {\n    const fields = payload || Object.keys(fieldsRef.current).map(name => ({\n      name\n    }));\n    if (validationSchema) return executeSchemaValidation(fields);\n\n    if (isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, false)));\n      render({});\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields, shouldRender);\n  }, [executeSchemaValidation, executeValidation, validationSchema]);\n  const setValue = useCallback((name, value, shouldValidate = false) => {\n    setValueInternal(name, value);\n    const shouldRender = isWatchAllRef.current || watchFieldsRef.current[name];\n\n    if (shouldValidate) {\n      return triggerValidation({\n        name\n      }, shouldRender);\n    }\n\n    if (shouldRender) render({});\n  }, [setValueInternal, triggerValidation]);\n  validateAndUpdateStateRef.current = validateAndUpdateStateRef.current ? validateAndUpdateStateRef.current : async event => {\n    const {\n      type,\n      target\n    } = event;\n    const name = target ? target.name : '';\n    if (isArray(validationFieldsRef.current) && !validationFieldsRef.current.includes(name)) return;\n    const fields = fieldsRef.current;\n    const errors = errorsRef.current;\n    const ref = fields[name];\n    let error;\n    if (!ref) return;\n    const isBlurEvent = type === EVENTS.BLUR;\n    const shouldSkipValidation = isOnSubmit && !isSubmittedRef.current || isOnBlur && !isBlurEvent && !errors[name] || isReValidateOnBlur && !isBlurEvent && errors[name] || isReValidateOnSubmit && errors[name];\n    const shouldUpdateDirty = setDirty(name);\n    let shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current[name] || shouldUpdateDirty;\n\n    if (!touchedFieldsRef.current.has(name)) {\n      touchedFieldsRef.current.add(name);\n      shouldUpdateState = true;\n    }\n\n    if (shouldSkipValidation) return shouldUpdateState ? render({}) : undefined;\n\n    if (validationSchema) {\n      const {\n        fieldErrors\n      } = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields)));\n      schemaErrorsRef.current = fieldErrors;\n      isSchemaValidateTriggeredRef.current = true;\n      error = fieldErrors[name] ? {\n        [name]: fieldErrors[name]\n      } : {};\n    } else {\n      error = await validateField(ref, fields, nativeValidation);\n    }\n\n    const shouldUpdate = shouldUpdateWithError({\n      errors,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n\n    if (shouldUpdate) {\n      errorsRef.current = combineErrorsRef(error);\n      renderBaseOnError(name, error);\n      return;\n    }\n\n    if (shouldUpdateState) render({});\n  };\n\n  const resetFieldRef = name => {\n    delete watchFieldsRef.current[name];\n    delete errorsRef.current[name];\n    delete fieldsRef.current[name];\n    delete defaultValuesRef.current[name];\n    [touchedFieldsRef, dirtyFieldsRef, fieldsWithValidationRef, validFieldsRef].forEach(data => data.current.delete(name));\n  };\n\n  const removeEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (!field) return;\n    findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndUpdateStateRef.current, field, forceDelete);\n    resetFieldRef(field.ref.name);\n  }, []);\n\n  function clearError(name) {\n    if (isUndefined(name)) {\n      errorsRef.current = {};\n    } else {\n      (isArray(name) ? name : [name]).forEach(fieldName => delete errorsRef.current[fieldName]);\n    }\n\n    render({});\n  }\n\n  const setError = (name, type, message, ref) => {\n    const errors = errorsRef.current;\n\n    if (!isSameError(errors[name], type, message)) {\n      errors[name] = {\n        type,\n        message,\n        ref,\n        isManual: true\n      };\n      render({});\n    }\n  };\n\n  function watch(fieldNames, defaultValue) {\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const watchFields = watchFieldsRef.current;\n\n    if (isString(fieldNames)) {\n      const value = assignWatchFields(fieldValues, fieldNames, watchFields);\n      return isUndefined(value) ? isUndefined(defaultValue) ? getDefaultValue(defaultValues, fieldNames) : defaultValue : value;\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => {\n        let value = getDefaultValue(defaultValues, name);\n\n        if (isEmptyObject(fieldsRef.current) && isObject(defaultValue)) {\n          value = defaultValue[name];\n        } else {\n          const tempValue = assignWatchFields(fieldValues, name, watchFields);\n          if (!isUndefined(tempValue)) value = tempValue;\n        }\n\n        return Object.assign(Object.assign({}, previous), {\n          [name]: value\n        });\n      }, {});\n    }\n\n    isWatchAllRef.current = true;\n    return !isEmptyObject(fieldValues) && fieldValues || defaultValue || defaultValues;\n  }\n\n  function registerIntoFieldsRef(ref, validateOptions = {}) {\n    if (!ref.name) return console.warn('Missing name on ref', ref);\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const typedName = name;\n    const fieldAttributes = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadio = isRadioInput(type);\n    let currentField = fields[typedName] || undefined;\n    const isRegistered = isRadio ? currentField && isArray(currentField.options) && currentField.options.find(({\n      ref\n    }) => value === ref.value) : currentField;\n    if (isRegistered) return;\n\n    if (!type) {\n      currentField = fieldAttributes;\n    } else {\n      const mutationWatcher = onDomRemove(ref, () => removeEventListenerAndRef(fieldAttributes));\n\n      if (isRadio) {\n        currentField = Object.assign({\n          options: [...(currentField && currentField.options ? currentField.options : []), {\n            ref,\n            mutationWatcher\n          }],\n          ref: {\n            type: RADIO_INPUT,\n            name\n          }\n        }, validateOptions);\n      } else {\n        currentField = Object.assign(Object.assign({}, fieldAttributes), {\n          mutationWatcher\n        });\n      }\n    }\n\n    fields[typedName] = currentField;\n\n    if (!isEmptyObject(defaultValues)) {\n      const defaultValue = getDefaultValue(defaultValues, name);\n      if (!isUndefined(defaultValue)) setFieldValue(name, defaultValue);\n    }\n\n    if (validateOptions && !isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit) {\n        if (validationSchema) {\n          isSchemaValidateTriggeredRef.current = true;\n          validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields))).then(({\n            fieldErrors\n          }) => {\n            schemaErrorsRef.current = fieldErrors;\n            if (isEmptyObject(schemaErrorsRef.current)) render({});\n          });\n        } else {\n          validateField(currentField, fields).then(error => {\n            if (isEmptyObject(error)) validFieldsRef.current.add(name);\n            if (validFieldsRef.current.size === fieldsWithValidationRef.current.size) render({});\n          });\n        }\n      }\n    }\n\n    if (!defaultValuesRef.current[typedName]) defaultValuesRef.current[typedName] = getFieldValue(fields, currentField.ref);\n    if (!type) return;\n    const fieldToRegister = isRadio && currentField.options ? currentField.options[currentField.options.length - 1] : currentField;\n    if (isOnSubmit && isReValidateOnSubmit) return;\n\n    if (nativeValidation && validateOptions) {\n      attachNativeValidation(ref, validateOptions);\n    } else {\n      attachEventListeners({\n        field: fieldToRegister,\n        isRadio,\n        validateAndStateUpdate: validateAndUpdateStateRef.current,\n        isOnBlur,\n        isReValidateOnBlur\n      });\n    }\n  }\n\n  function register(refOrValidateRule, validationOptions) {\n    if (typeof window === UNDEFINED || !refOrValidateRule) return;\n\n    if (isObject(refOrValidateRule) && (validationOptions || 'name' in refOrValidateRule)) {\n      registerIntoFieldsRef(refOrValidateRule, validationOptions);\n      return;\n    }\n\n    return ref => ref && registerIntoFieldsRef(ref, refOrValidateRule);\n  }\n\n  function unregister(names) {\n    if (isEmptyObject(fieldsRef.current)) return;\n    (isArray(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));\n  }\n\n  const handleSubmit = callback => async e => {\n    if (e) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors;\n    let fieldValues;\n    const fields = fieldsRef.current;\n    const fieldsToValidate = validationFields ? validationFields.map(name => fieldsRef.current[name]) : Object.values(fields);\n    isSubmittingRef.current = true;\n    render({});\n\n    if (validationSchema) {\n      fieldValues = getFieldsValues(fields);\n      const output = await validateWithSchemaCurry(combineFieldValues(fieldValues));\n      schemaErrorsRef.current = output.fieldErrors;\n      fieldErrors = output.fieldErrors;\n      fieldValues = output.result;\n    } else {\n      const {\n        errors,\n        values\n      } = await fieldsToValidate.reduce(async (previous, field) => {\n        if (!field) return previous;\n        const resolvedPrevious = await previous;\n        const {\n          ref,\n          ref: {\n            name\n          }\n        } = field;\n        if (!fields[name]) return Promise.resolve(resolvedPrevious);\n        const fieldError = await validateField(field, fields, nativeValidation);\n\n        if (fieldError[name]) {\n          resolvedPrevious.errors = Object.assign(Object.assign({}, resolvedPrevious.errors), fieldError);\n          validFieldsRef.current.delete(name);\n          return Promise.resolve(resolvedPrevious);\n        }\n\n        if (fieldsWithValidationRef.current.has(name)) validFieldsRef.current.add(name);\n        resolvedPrevious.values[name] = getFieldValue(fields, ref);\n        return Promise.resolve(resolvedPrevious);\n      }, Promise.resolve({\n        errors: {},\n        values: {}\n      }));\n      fieldErrors = errors;\n      fieldValues = values;\n    }\n\n    if (isEmptyObject(fieldErrors)) {\n      errorsRef.current = {};\n      await callback(combineFieldValues(fieldValues), e);\n    } else {\n      if (submitFocusError) {\n        Object.keys(fieldErrors).reduce((previous, current) => {\n          const field = fields[current];\n\n          if (field && field.ref.focus && previous) {\n            field.ref.focus();\n            return false;\n          }\n\n          return previous;\n        }, true);\n      }\n\n      errorsRef.current = fieldErrors;\n    }\n\n    if (isUnMount.current) return;\n    isSubmittedRef.current = true;\n    isSubmittingRef.current = false;\n    submitCountRef.current = submitCountRef.current + 1;\n    render({});\n  };\n\n  const resetRefs = () => {\n    errorsRef.current = {};\n    schemaErrorsRef.current = {};\n    touchedFieldsRef.current = new Set();\n    watchFieldsRef.current = {};\n    dirtyFieldsRef.current = new Set();\n    fieldsWithValidationRef.current = new Set();\n    validFieldsRef.current = new Set();\n    defaultValuesRef.current = {};\n    isWatchAllRef.current = false;\n    isSubmittedRef.current = false;\n    isDirtyRef.current = false;\n    isSchemaValidateTriggeredRef.current = false;\n  };\n\n  const reset = useCallback(values => {\n    const fieldsKeyValue = Object.entries(fieldsRef.current);\n\n    for (let [, value] of fieldsKeyValue) {\n      if (value && value.ref && value.ref.closest) {\n        try {\n          value.ref.closest('form').reset();\n          break;\n        } catch (_a) {}\n      }\n    }\n\n    resetRefs();\n\n    if (values) {\n      fieldsKeyValue.forEach(([key]) => setFieldValue(key, getDefaultValue(values, key)));\n      defaultValuesRef.current = Object.assign({}, values);\n    }\n\n    submitCountRef.current = 0;\n    render({});\n  }, []);\n\n  const getValues = payload => {\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const output = payload && payload.nest ? combineFieldValues(fieldValues) : fieldValues;\n    return isEmptyObject(output) ? defaultValues : output;\n  };\n\n  useEffect(() => () => {\n    isUnMount.current = true;\n    fieldsRef.current && Object.values(fieldsRef.current).forEach(field => removeEventListenerAndRef(field, true));\n  }, [removeEventListenerAndRef]);\n  return {\n    register: useCallback(register, [registerIntoFieldsRef]),\n    unregister: useCallback(unregister, [unregister, removeEventListenerAndRef]),\n    handleSubmit,\n    watch,\n    reset,\n    clearError,\n    setError,\n    setValue,\n    triggerValidation,\n    getValues,\n    errors: validationFields ? pickErrors(errorsRef.current, validationFields) : errorsRef.current,\n    formState: Object.assign({\n      dirty: isDirtyRef.current,\n      isSubmitted: isSubmittedRef.current,\n      submitCount: submitCountRef.current,\n      touched: [...touchedFieldsRef.current],\n      isSubmitting: isSubmittingRef.current\n    }, isOnSubmit ? {\n      isValid: isEmptyObject(errorsRef.current)\n    } : {\n      isValid: validationSchema ? isSchemaValidateTriggeredRef.current && isEmptyObject(schemaErrorsRef.current) : fieldsWithValidationRef.current.size ? !isEmptyObject(fieldsRef.current) && validFieldsRef.current.size >= fieldsWithValidationRef.current.size : !isEmptyObject(fieldsRef.current)\n    })\n  };\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormGlobalContext = createContext(null);\n\nfunction useFormContext() {\n  return useContext(FormGlobalContext);\n}\n\nfunction FormContext(props) {\n  const {\n    children,\n    formState,\n    errors\n  } = props,\n        restMethods = __rest(props, [\"children\", \"formState\", \"errors\"]);\n\n  const restRef = useRef(restMethods);\n  return createElement(FormGlobalContext.Provider, {\n    value: Object.assign(Object.assign({}, restRef.current), {\n      formState,\n      errors\n    })\n  }, children);\n}\n\nexport default useForm;\nexport { FormContext, useFormContext };","map":{"version":3,"sources":["/Users/kimberlyzhu/Documents/MeetingGround/node_modules/react-hook-form/dist/react-hook-form.es.js"],"names":["useRef","useState","useCallback","useEffect","createContext","useContext","createElement","isCheckBoxInput","type","VALIDATION_MODE","onBlur","onChange","onSubmit","RADIO_INPUT","REQUIRED_ATTRIBUTE","PATTERN_ATTRIBUTE","UNDEFINED","EVENTS","BLUR","CHANGE","INPUT","attachEventListeners","field","validateAndStateUpdate","isRadio","isOnBlur","isReValidateOnBlur","ref","addEventListener","isUndefined","val","undefined","isNullOrUndefined","value","isArray","Array","isObject","reIsDeepProp","reIsPlainProp","rePropName","reEscapeChar","reIsUint","isIndex","test","isKey","stringToPath","string","result","replace","match","number","quote","push","set","object","path","index","tempPath","length","lastIndex","key","newValue","objValue","combineFieldValues","data","Object","entries","reduce","previous","indexOf","assign","removeAllEventListeners","validateWithStateUpdate","removeEventListener","isRadioInput","isDetached","element","HTMLElement","nodeType","Node","DOCUMENT_NODE","parentNode","findRemovedFieldAndRemoveListener","fields","forceDelete","mutationWatcher","options","name","forEach","disconnect","splice","defaultReturn","isValid","getRadioValue","checked","getMultipleSelectValue","filter","selected","map","isMultipleSelect","getFieldValue","files","attributes","getFieldsValues","values","isEmptyObject","keys","isSameError","error","message","shouldUpdateWithError","errors","validFields","fieldsWithValidation","has","isManual","isRegex","RegExp","getValueAndMessage","validationData","isString","displayNativeError","nativeValidation","setCustomValidity","isFunction","isBoolean","getValidateFunctionErrorObject","nativeError","isStringValue","validateField","required","maxLength","minLength","min","max","pattern","validate","isCheckBox","bind","typedName","exceedMax","exceedMin","maxValue","maxMessage","minValue","minMessage","valueNumber","parseFloat","Date","maxLengthValue","maxLengthMessage","minLengthValue","minLengthMessage","inputLength","toString","patternValue","patternMessage","fieldValue","validateRef","errorObject","validationResult","Promise","resolve","lastChild","parseErrorSchema","inner","validateWithSchema","validationSchema","validationSchemaOption","fieldErrors","e","attachNativeValidation","rules","source","get","obj","defaultValue","String","prototype","split","call","Boolean","res","getDefaultValue","defaultValues","flatArray","list","a","b","concat","getPath","item","pathWithIndex","objectValue","getPath$1","parentPath","assignWatchFields","fieldValues","fieldName","watchFields","omitValidFields","errorFields","validFieldNames","some","validFieldName","onDomRemove","onDetachCallback","observer","MutationObserver","observe","window","document","childList","subtree","modeChecker","mode","isOnSubmit","isOnChange","pickErrors","pickList","includes","useForm","reValidateMode","validationFields","submitFocusError","abortEarly","fieldsRef","errorsRef","schemaErrorsRef","touchedFieldsRef","Set","watchFieldsRef","dirtyFieldsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","isUnMount","isWatchAllRef","isSubmittedRef","isDirtyRef","submitCountRef","isSubmittingRef","isSchemaValidateTriggeredRef","validationFieldsRef","validateAndUpdateStateRef","render","current","isReValidateOnSubmit","validationSchemaOptionRef","combineErrorsRef","renderBaseOnError","shouldRender","add","delete","setFieldValue","rawValue","radioRef","selectRef","setDirty","isDirty","isDirtyChanged","size","setValueInternal","executeValidation","validateWithSchemaCurry","executeSchemaValidation","payload","names","triggerValidation","all","every","setValue","shouldValidate","event","target","isBlurEvent","shouldSkipValidation","shouldUpdateDirty","shouldUpdateState","shouldUpdate","resetFieldRef","removeEventListenerAndRef","clearError","setError","watch","fieldNames","tempValue","registerIntoFieldsRef","validateOptions","console","warn","fieldAttributes","currentField","isRegistered","find","then","fieldToRegister","register","refOrValidateRule","validationOptions","unregister","handleSubmit","callback","preventDefault","persist","fieldsToValidate","output","resolvedPrevious","fieldError","focus","resetRefs","reset","fieldsKeyValue","closest","_a","getValues","nest","formState","dirty","isSubmitted","submitCount","touched","isSubmitting","__rest","s","t","p","hasOwnProperty","getOwnPropertySymbols","i","propertyIsEnumerable","FormGlobalContext","useFormContext","FormContext","props","children","restMethods","restRef","Provider"],"mappings":"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","sourcesContent":["import { useRef, useState, useCallback, useEffect, createContext, useContext, createElement } from 'react';\n\nvar isCheckBoxInput = (type) => type === 'checkbox';\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst RADIO_INPUT = 'radio';\r\nconst REQUIRED_ATTRIBUTE = 'required';\r\nconst PATTERN_ATTRIBUTE = 'pattern';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\n\nfunction attachEventListeners({ field, validateAndStateUpdate, isRadio, isOnBlur, isReValidateOnBlur, }) {\r\n    const { ref } = field;\r\n    if (!ref.addEventListener)\r\n        return;\r\n    ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? EVENTS.CHANGE : EVENTS.INPUT, validateAndStateUpdate);\r\n    if (isOnBlur || isReValidateOnBlur)\r\n        ref.addEventListener(EVENTS.BLUR, validateAndStateUpdate);\r\n}\n\nvar isUndefined = (val) => val === undefined;\n\nvar isNullOrUndefined = (value) => value === null || isUndefined(value);\n\nvar isArray = (value) => Array.isArray(value);\n\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && typeof value === 'object';\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst reIsPlainProp = /^\\w*$/;\r\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst reEscapeChar = /\\\\(\\\\)?/g;\r\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\r\nfunction isIndex(value) {\r\n    return reIsUint.test(value) && value > -1;\r\n}\r\nfunction isKey(value) {\r\n    if (isArray(value))\r\n        return false;\r\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);\r\n}\r\nconst stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(rePropName, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\r\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : isIndex(tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar combineFieldValues = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!!key.match(/\\[.+\\]/gi) || key.indexOf('.') > 0) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (!ref.removeEventListener)\r\n        return;\r\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n};\n\nvar isRadioInput = (type) => type === RADIO_INPUT;\n\nfunction isDetached(element) {\r\n    if (!element)\r\n        return true;\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE)\r\n        return false;\r\n    return isDetached(element.parentNode);\r\n}\n\nfunction findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate = () => { }, field, forceDelete = false) {\r\n    if (!field)\r\n        return;\r\n    const { ref, mutationWatcher, options } = field;\r\n    if (!ref || !ref.type)\r\n        return;\r\n    const { name, type } = ref;\r\n    if (isRadioInput(type) && options) {\r\n        options.forEach(({ ref }, index) => {\r\n            if ((options[index] && isDetached(ref)) || forceDelete) {\r\n                removeAllEventListeners(options[index], validateWithStateUpdate);\r\n                (options[index].mutationWatcher || { disconnect: () => { } }).disconnect();\r\n                options.splice(index, 1);\r\n            }\r\n        });\r\n        if (!options.length)\r\n            delete fields[name];\r\n    }\r\n    else if (isDetached(ref) || forceDelete) {\r\n        removeAllEventListeners(ref, validateWithStateUpdate);\r\n        if (mutationWatcher)\r\n            mutationWatcher.disconnect();\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, { ref: { checked, value } }) => checked\r\n        ? {\r\n            isValid: true,\r\n            value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isMultipleSelect = (type) => type === 'select-multiple';\n\nfunction getFieldValue(fields, ref) {\r\n    const { type, name, options, checked, value, files } = ref;\r\n    if (type === 'file') {\r\n        return files;\r\n    }\r\n    if (isRadioInput(type)) {\r\n        const field = fields[name];\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(type))\r\n        return getMultipleSelectValue(options);\r\n    if (isCheckBoxInput(type)) {\r\n        if (checked) {\r\n            return ref.attributes && ref.attributes.value\r\n                ? isUndefined(value) || value === ''\r\n                    ? true\r\n                    : value\r\n                : true;\r\n        }\r\n        return false;\r\n    }\r\n    return value;\r\n}\n\nvar getFieldsValues = (fields) => Object.values(fields).reduce((previous, { ref, ref: { name } }) => (Object.assign(Object.assign({}, previous), { [name]: getFieldValue(fields, ref) })), {});\n\nvar isEmptyObject = (value) => isObject(value) && Object.keys(value).length === 0;\n\nvar isSameError = (error, type, message) => isObject(error) && (error.type === type && error.message === message);\n\n// TODO: improve the types in this file\r\nfunction shouldUpdateWithError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    if ((validFields.has(name) && isEmptyObject(error)) ||\r\n        (errors[name] && errors[name].isManual)) {\r\n        return false;\r\n    }\r\n    if ((fieldsWithValidation.has(name) &&\r\n        !validFields.has(name) &&\r\n        isEmptyObject(error)) ||\r\n        (isEmptyObject(errors) && !isEmptyObject(error)) ||\r\n        (isEmptyObject(error) && errors[name]) ||\r\n        !errors[name]) {\r\n        return true;\r\n    }\r\n    return (errors[name] &&\r\n        error[name] &&\r\n        !isSameError(errors[name], error[name].type, error[name].message));\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => ({\r\n    value: isObject(validationData) && !isRegex(validationData)\r\n        ? validationData.value\r\n        : validationData,\r\n    message: isObject(validationData) && !isRegex(validationData)\r\n        ? validationData.message\r\n        : '',\r\n});\n\nvar isString = (value) => typeof value === 'string';\n\nvar displayNativeError = (nativeValidation, ref, message) => {\r\n    if (nativeValidation && isString(message))\r\n        ref.setCustomValidity(message);\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction getValidateFunctionErrorObject(result, ref, nativeError, type = 'validate') {\r\n    const isStringValue = isString(result);\r\n    if (isStringValue || (isBoolean(result) && !result)) {\r\n        const message = isStringValue ? result : '';\r\n        const error = {\r\n            type,\r\n            message,\r\n            ref,\r\n        };\r\n        nativeError(message);\r\n        return error;\r\n    }\r\n    return;\r\n}\n\nvar validateField = async ({ ref, ref: { type, value, name, checked }, options, required, maxLength, minLength, min, max, pattern, validate, }, fields, nativeValidation) => {\r\n    const error = {};\r\n    const isRadio = isRadioInput(type);\r\n    const isCheckBox = isCheckBoxInput(type);\r\n    const nativeError = displayNativeError.bind(null, nativeValidation, ref);\r\n    const typedName = name;\r\n    if (required &&\r\n        ((isCheckBox && !checked) ||\r\n            (!isCheckBox && !isRadio && value === '') ||\r\n            (isRadio && !getRadioValue(fields[typedName].options).isValid) ||\r\n            (!type && isNullOrUndefined(value)))) {\r\n        error[typedName] = {\r\n            type: REQUIRED_ATTRIBUTE,\r\n            message: isString(required) ? required : '',\r\n            ref: isRadio ? fields[typedName].options[0].ref : ref,\r\n        };\r\n        nativeError(required);\r\n        return error;\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number') {\r\n            const valueNumber = parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue))\r\n                exceedMax = valueNumber > maxValue;\r\n            if (!isNullOrUndefined(minValue))\r\n                exceedMin = valueNumber < minValue;\r\n        }\r\n        else {\r\n            if (isString(maxValue))\r\n                exceedMax = new Date(value) > new Date(maxValue);\r\n            if (isString(minValue))\r\n                exceedMin = new Date(value) < new Date(minValue);\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            const message = exceedMax ? maxMessage : minMessage;\r\n            error[typedName] = {\r\n                type: exceedMax ? 'max' : 'min',\r\n                message,\r\n                ref,\r\n            };\r\n            nativeError(message);\r\n            return error;\r\n        }\r\n    }\r\n    if ((maxLength || minLength) && isString(value)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = maxLength && inputLength > maxLengthValue;\r\n        const exceedMin = minLength && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n            error[typedName] = {\r\n                type: exceedMax ? 'maxLength' : 'minLength',\r\n                message,\r\n                ref,\r\n            };\r\n            nativeError(message);\r\n            return error;\r\n        }\r\n    }\r\n    if (pattern) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[typedName] = {\r\n                type: PATTERN_ATTRIBUTE,\r\n                message: patternMessage,\r\n                ref,\r\n            };\r\n            nativeError(patternMessage);\r\n            return error;\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadio && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const errorObject = getValidateFunctionErrorObject(result, validateRef, nativeError);\r\n            if (errorObject) {\r\n                error[typedName] = errorObject;\r\n                return error;\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            const validationResult = await new Promise((resolve) => {\r\n                const values = Object.entries(validate);\r\n                values.reduce(async (previous, [key, validate], index) => {\r\n                    const lastChild = values.length - 1 === index;\r\n                    if (isFunction(validate)) {\r\n                        const result = await validate(fieldValue);\r\n                        const errorObject = getValidateFunctionErrorObject(result, validateRef, nativeError, key);\r\n                        if (errorObject) {\r\n                            return lastChild ? resolve(errorObject) : errorObject;\r\n                        }\r\n                    }\r\n                    return lastChild ? resolve(previous) : previous;\r\n                }, {});\r\n            });\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[typedName] = Object.assign({ ref: validateRef }, validationResult);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (nativeValidation)\r\n        ref.setCustomValidity('');\r\n    return error;\r\n};\n\n// TODO: Fix these types\r\nconst parseErrorSchema = (error) => error.inner.length\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), { [path]: { message, ref: {}, type } })), {})\r\n    : {\r\n        [error.path]: { message: error.message, ref: {}, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validationSchemaOption, data) {\r\n    try {\r\n        return {\r\n            result: await validationSchema.validate(data, validationSchemaOption),\r\n            fieldErrors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            result: {},\r\n            fieldErrors: parseErrorSchema(e),\r\n        };\r\n    }\r\n}\n\nfunction attachNativeValidation(ref, rules) {\r\n    Object.entries(rules).forEach(([key, value]) => {\r\n        if (key === PATTERN_ATTRIBUTE && isRegex(value)) {\r\n            ref[key] = value.source;\r\n        }\r\n        else {\r\n            ref[key] = key === REQUIRED_ATTRIBUTE ? true : value;\r\n        }\r\n    });\r\n}\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = String.prototype.split\r\n        .call(path, /[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);\r\n    return result === undefined || result === obj ? defaultValue : result;\r\n};\n\nvar getDefaultValue = (defaultValues, name, defaultValue) => isUndefined(defaultValues[name])\r\n    ? get(defaultValues, name, defaultValue)\r\n    : defaultValues[name];\n\nfunction flatArray(list) {\r\n    return list.reduce((a, b) => a.concat(isArray(b) ? flatArray(b) : b), []);\r\n}\n\nconst getPath = (path, values) => isArray(values)\r\n    ? values.map((item, index) => {\r\n        const pathWithIndex = `${path}[${index}]`;\r\n        if (isArray(item)) {\r\n            return getPath(pathWithIndex, item);\r\n        }\r\n        else if (isObject(item)) {\r\n            return Object.entries(item).map(([key, objectValue]) => isString(objectValue)\r\n                ? `${pathWithIndex}.${key}`\r\n                : getPath(`${pathWithIndex}.${key}`, objectValue));\r\n        }\r\n        return pathWithIndex;\r\n    })\r\n    : Object.entries(values).map(([key, objectValue]) => isString(objectValue) ? `${path}.${key}` : getPath(path, objectValue));\r\nvar getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields) => {\r\n    if (isNullOrUndefined(fieldValues) || isEmptyObject(fieldValues))\r\n        return undefined;\r\n    if (!isUndefined(fieldValues[fieldName])) {\r\n        watchFields[fieldName] = true;\r\n        return fieldValues[fieldName];\r\n    }\r\n    const values = get(combineFieldValues(fieldValues), fieldName);\r\n    if (!isUndefined(values)) {\r\n        const result = getPath$1(fieldName, values);\r\n        if (isArray(result)) {\r\n            result.forEach(name => {\r\n                watchFields[name] = true;\r\n            });\r\n        }\r\n    }\r\n    return values;\r\n};\n\nvar omitValidFields = (errorFields, validFieldNames) => Object.entries(errorFields).reduce((previous, [name, error]) => validFieldNames.some((validFieldName) => validFieldName === name)\r\n    ? previous\r\n    : Object.assign(Object.assign({}, previous), { [name]: error }), {});\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nvar pickErrors = (errors, pickList) => Object.entries(errors).reduce((previous, [key, error]) => (Object.assign(Object.assign({}, previous), (pickList.includes(key) ? { [key]: error } : null))), {});\n\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, defaultValues = {}, validationFields, nativeValidation, submitFocusError = true, validationSchemaOption = { abortEarly: false }, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const errorsRef = useRef({});\r\n    const schemaErrorsRef = useRef({});\r\n    const touchedFieldsRef = useRef(new Set());\r\n    const watchFieldsRef = useRef({});\r\n    const dirtyFieldsRef = useRef(new Set());\r\n    const fieldsWithValidationRef = useRef(new Set());\r\n    const validFieldsRef = useRef(new Set());\r\n    const defaultValuesRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const isSubmittedRef = useRef(false);\r\n    const isDirtyRef = useRef(false);\r\n    const submitCountRef = useRef(0);\r\n    const isSubmittingRef = useRef(false);\r\n    const isSchemaValidateTriggeredRef = useRef(false);\r\n    const validationFieldsRef = useRef(validationFields);\r\n    const validateAndUpdateStateRef = useRef();\r\n    const [, render] = useState();\r\n    const { isOnBlur, isOnSubmit } = useRef(modeChecker(mode)).current;\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = useRef(modeChecker(reValidateMode)).current;\r\n    const validationSchemaOptionRef = useRef(validationSchemaOption);\r\n    validationFieldsRef.current = validationFields;\r\n    const combineErrorsRef = (data) => (Object.assign(Object.assign({}, errorsRef.current), data));\r\n    const renderBaseOnError = useCallback((name, error, shouldRender = true) => {\r\n        if (isEmptyObject(error)) {\r\n            delete errorsRef.current[name];\r\n            if (fieldsWithValidationRef.current.has(name) || validationSchema)\r\n                validFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            validFieldsRef.current.delete(name);\r\n        }\r\n        if (shouldRender)\r\n            render({});\r\n    }, [validationSchema]);\r\n    const setFieldValue = (name, rawValue) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!field)\r\n            return false;\r\n        const ref = field.ref;\r\n        const { type } = ref;\r\n        const options = field.options;\r\n        const value = typeof document !== UNDEFINED &&\r\n            typeof window !== UNDEFINED &&\r\n            !isUndefined(window.HTMLElement) &&\r\n            ref instanceof window.HTMLElement &&\r\n            isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(type) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isMultipleSelect(type)) {\r\n            [...ref.options].forEach(selectRef => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else {\r\n            ref[isCheckBoxInput(type) ? 'checked' : 'value'] = value;\r\n        }\r\n        return type;\r\n    };\r\n    const setDirty = (name) => {\r\n        if (!fieldsRef.current[name])\r\n            return false;\r\n        const isDirty = defaultValuesRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;\r\n        if (isDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = !!dirtyFieldsRef.current.size;\r\n        return isDirtyChanged;\r\n    };\r\n    const setValueInternal = useCallback((name, value) => {\r\n        const shouldRender = setFieldValue(name, value);\r\n        if (setDirty(name) ||\r\n            shouldRender ||\r\n            !touchedFieldsRef.current.has(name)) {\r\n            touchedFieldsRef.current.add(name);\r\n            render({});\r\n        }\r\n    }, []);\r\n    const executeValidation = useCallback(async ({ name, value, }, shouldRender = true) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!field)\r\n            return false;\r\n        if (!isUndefined(value))\r\n            setValueInternal(name, value);\r\n        const error = await validateField(field, fieldsRef.current);\r\n        errorsRef.current = combineErrorsRef(error);\r\n        renderBaseOnError(name, error, shouldRender);\r\n        return isEmptyObject(error);\r\n    }, [renderBaseOnError, setValueInternal]);\r\n    const validateWithSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOptionRef.current), [validationSchema]);\r\n    const executeSchemaValidation = useCallback(async (payload) => {\r\n        const { fieldErrors } = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fieldsRef.current)));\r\n        const names = isArray(payload)\r\n            ? payload.map(({ name }) => name)\r\n            : [payload.name];\r\n        const validFieldNames = names.filter(name => !fieldErrors[name]);\r\n        schemaErrorsRef.current = fieldErrors;\r\n        isSchemaValidateTriggeredRef.current = true;\r\n        errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors)\r\n            .filter(([key]) => names.includes(key))\r\n            .reduce((previous, [name, error]) => (Object.assign(Object.assign({}, previous), { [name]: error })), {})), validFieldNames);\r\n        render({});\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [validateWithSchemaCurry]);\r\n    const triggerValidation = useCallback(async (payload, shouldRender) => {\r\n        const fields = payload || Object.keys(fieldsRef.current).map(name => ({ name }));\r\n        if (validationSchema)\r\n            return executeSchemaValidation(fields);\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, false)));\r\n            render({});\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields, shouldRender);\r\n    }, [executeSchemaValidation, executeValidation, validationSchema]);\r\n    const setValue = useCallback((name, value, shouldValidate = false) => {\r\n        setValueInternal(name, value);\r\n        const shouldRender = isWatchAllRef.current || watchFieldsRef.current[name];\r\n        if (shouldValidate) {\r\n            return triggerValidation({ name }, shouldRender);\r\n        }\r\n        if (shouldRender)\r\n            render({});\r\n    }, [setValueInternal, triggerValidation]);\r\n    validateAndUpdateStateRef.current = validateAndUpdateStateRef.current\r\n        ? validateAndUpdateStateRef.current\r\n        : async (event) => {\r\n            const { type, target } = event;\r\n            const name = target ? target.name : '';\r\n            if (isArray(validationFieldsRef.current) &&\r\n                !validationFieldsRef.current.includes(name))\r\n                return;\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const ref = fields[name];\r\n            let error;\r\n            if (!ref)\r\n                return;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = (isOnSubmit && !isSubmittedRef.current) ||\r\n                (isOnBlur && !isBlurEvent && !errors[name]) ||\r\n                (isReValidateOnBlur && !isBlurEvent && errors[name]) ||\r\n                (isReValidateOnSubmit && errors[name]);\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldUpdateState = isWatchAllRef.current ||\r\n                watchFieldsRef.current[name] ||\r\n                shouldUpdateDirty;\r\n            if (!touchedFieldsRef.current.has(name)) {\r\n                touchedFieldsRef.current.add(name);\r\n                shouldUpdateState = true;\r\n            }\r\n            if (shouldSkipValidation)\r\n                return shouldUpdateState ? render({}) : undefined;\r\n            if (validationSchema) {\r\n                const { fieldErrors } = await validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields)));\r\n                schemaErrorsRef.current = fieldErrors;\r\n                isSchemaValidateTriggeredRef.current = true;\r\n                error = fieldErrors[name]\r\n                    ? { [name]: fieldErrors[name] }\r\n                    : {};\r\n            }\r\n            else {\r\n                error = await validateField(ref, fields, nativeValidation);\r\n            }\r\n            const shouldUpdate = shouldUpdateWithError({\r\n                errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n            if (shouldUpdate) {\r\n                errorsRef.current = combineErrorsRef(error);\r\n                renderBaseOnError(name, error);\r\n                return;\r\n            }\r\n            if (shouldUpdateState)\r\n                render({});\r\n        };\r\n    const resetFieldRef = (name) => {\r\n        delete watchFieldsRef.current[name];\r\n        delete errorsRef.current[name];\r\n        delete fieldsRef.current[name];\r\n        delete defaultValuesRef.current[name];\r\n        [\r\n            touchedFieldsRef,\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n        ].forEach(data => data.current.delete(name));\r\n    };\r\n    const removeEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (!field)\r\n            return;\r\n        findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndUpdateStateRef.current, field, forceDelete);\r\n        resetFieldRef(field.ref.name);\r\n    }, []);\r\n    function clearError(name) {\r\n        if (isUndefined(name)) {\r\n            errorsRef.current = {};\r\n        }\r\n        else {\r\n            (isArray(name) ? name : [name]).forEach(fieldName => delete errorsRef.current[fieldName]);\r\n        }\r\n        render({});\r\n    }\r\n    const setError = (name, type, message, ref) => {\r\n        const errors = errorsRef.current;\r\n        if (!isSameError(errors[name], type, message)) {\r\n            errors[name] = {\r\n                type,\r\n                message,\r\n                ref,\r\n                isManual: true,\r\n            };\r\n            render({});\r\n        }\r\n    };\r\n    function watch(fieldNames, defaultValue) {\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const watchFields = watchFieldsRef.current;\r\n        if (isString(fieldNames)) {\r\n            const value = assignWatchFields(fieldValues, fieldNames, watchFields);\r\n            return isUndefined(value)\r\n                ? isUndefined(defaultValue)\r\n                    ? getDefaultValue(defaultValues, fieldNames)\r\n                    : defaultValue\r\n                : value;\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => {\r\n                let value = getDefaultValue(defaultValues, name);\r\n                if (isEmptyObject(fieldsRef.current) && isObject(defaultValue)) {\r\n                    value = defaultValue[name];\r\n                }\r\n                else {\r\n                    const tempValue = assignWatchFields(fieldValues, name, watchFields);\r\n                    if (!isUndefined(tempValue))\r\n                        value = tempValue;\r\n                }\r\n                return Object.assign(Object.assign({}, previous), { [name]: value });\r\n            }, {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        return ((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            defaultValue ||\r\n            defaultValues);\r\n    }\r\n    function registerIntoFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name)\r\n            return console.warn('Missing name on ref', ref);\r\n        const { name, type, value } = ref;\r\n        const typedName = name;\r\n        const fieldAttributes = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadio = isRadioInput(type);\r\n        let currentField = (fields[typedName] || undefined);\r\n        const isRegistered = isRadio\r\n            ? currentField &&\r\n                isArray(currentField.options) &&\r\n                currentField.options.find(({ ref }) => value === ref.value)\r\n            : currentField;\r\n        if (isRegistered)\r\n            return;\r\n        if (!type) {\r\n            currentField = fieldAttributes;\r\n        }\r\n        else {\r\n            const mutationWatcher = onDomRemove(ref, () => removeEventListenerAndRef(fieldAttributes));\r\n            if (isRadio) {\r\n                currentField = Object.assign({ options: [\r\n                        ...(currentField && currentField.options\r\n                            ? currentField.options\r\n                            : []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type: RADIO_INPUT, name } }, validateOptions);\r\n            }\r\n            else {\r\n                currentField = Object.assign(Object.assign({}, fieldAttributes), { mutationWatcher });\r\n            }\r\n        }\r\n        fields[typedName] = currentField;\r\n        if (!isEmptyObject(defaultValues)) {\r\n            const defaultValue = getDefaultValue(defaultValues, name);\r\n            if (!isUndefined(defaultValue))\r\n                setFieldValue(name, defaultValue);\r\n        }\r\n        if (validateOptions && !isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit) {\r\n                if (validationSchema) {\r\n                    isSchemaValidateTriggeredRef.current = true;\r\n                    validateWithSchemaCurry(combineFieldValues(getFieldsValues(fields))).then(({ fieldErrors }) => {\r\n                        schemaErrorsRef.current = fieldErrors;\r\n                        if (isEmptyObject(schemaErrorsRef.current))\r\n                            render({});\r\n                    });\r\n                }\r\n                else {\r\n                    validateField(currentField, fields).then(error => {\r\n                        if (isEmptyObject(error))\r\n                            validFieldsRef.current.add(name);\r\n                        if (validFieldsRef.current.size ===\r\n                            fieldsWithValidationRef.current.size)\r\n                            render({});\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (!defaultValuesRef.current[typedName])\r\n            defaultValuesRef.current[typedName] = getFieldValue(fields, currentField.ref);\r\n        if (!type)\r\n            return;\r\n        const fieldToRegister = isRadio && currentField.options\r\n            ? currentField.options[currentField.options.length - 1]\r\n            : currentField;\r\n        if (isOnSubmit && isReValidateOnSubmit)\r\n            return;\r\n        if (nativeValidation && validateOptions) {\r\n            attachNativeValidation(ref, validateOptions);\r\n        }\r\n        else {\r\n            attachEventListeners({\r\n                field: fieldToRegister,\r\n                isRadio,\r\n                validateAndStateUpdate: validateAndUpdateStateRef.current,\r\n                isOnBlur,\r\n                isReValidateOnBlur,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidateRule, validationOptions) {\r\n        if (typeof window === UNDEFINED || !refOrValidateRule)\r\n            return;\r\n        if (isObject(refOrValidateRule) &&\r\n            (validationOptions || 'name' in refOrValidateRule)) {\r\n            registerIntoFieldsRef(refOrValidateRule, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerIntoFieldsRef(ref, refOrValidateRule);\r\n    }\r\n    function unregister(names) {\r\n        if (isEmptyObject(fieldsRef.current))\r\n            return;\r\n        (isArray(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n    }\r\n    const handleSubmit = (callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors;\r\n        let fieldValues;\r\n        const fields = fieldsRef.current;\r\n        const fieldsToValidate = validationFields\r\n            ? validationFields.map(name => fieldsRef.current[name])\r\n            : Object.values(fields);\r\n        isSubmittingRef.current = true;\r\n        render({});\r\n        if (validationSchema) {\r\n            fieldValues = getFieldsValues(fields);\r\n            const output = await validateWithSchemaCurry(combineFieldValues(fieldValues));\r\n            schemaErrorsRef.current = output.fieldErrors;\r\n            fieldErrors = output.fieldErrors;\r\n            fieldValues = output.result;\r\n        }\r\n        else {\r\n            const { errors, values, } = await fieldsToValidate.reduce(async (previous, field) => {\r\n                if (!field)\r\n                    return previous;\r\n                const resolvedPrevious = await previous;\r\n                const { ref, ref: { name }, } = field;\r\n                if (!fields[name])\r\n                    return Promise.resolve(resolvedPrevious);\r\n                const fieldError = await validateField(field, fields, nativeValidation);\r\n                if (fieldError[name]) {\r\n                    resolvedPrevious.errors = Object.assign(Object.assign({}, resolvedPrevious.errors), fieldError);\r\n                    validFieldsRef.current.delete(name);\r\n                    return Promise.resolve(resolvedPrevious);\r\n                }\r\n                if (fieldsWithValidationRef.current.has(name))\r\n                    validFieldsRef.current.add(name);\r\n                resolvedPrevious.values[name] = getFieldValue(fields, ref);\r\n                return Promise.resolve(resolvedPrevious);\r\n            }, Promise.resolve({\r\n                errors: {},\r\n                values: {},\r\n            }));\r\n            fieldErrors = errors;\r\n            fieldValues = values;\r\n        }\r\n        if (isEmptyObject(fieldErrors)) {\r\n            errorsRef.current = {};\r\n            await callback(combineFieldValues(fieldValues), e);\r\n        }\r\n        else {\r\n            if (submitFocusError) {\r\n                Object.keys(fieldErrors).reduce((previous, current) => {\r\n                    const field = fields[current];\r\n                    if (field && field.ref.focus && previous) {\r\n                        field.ref.focus();\r\n                        return false;\r\n                    }\r\n                    return previous;\r\n                }, true);\r\n            }\r\n            errorsRef.current = fieldErrors;\r\n        }\r\n        if (isUnMount.current)\r\n            return;\r\n        isSubmittedRef.current = true;\r\n        isSubmittingRef.current = false;\r\n        submitCountRef.current = submitCountRef.current + 1;\r\n        render({});\r\n    };\r\n    const resetRefs = () => {\r\n        errorsRef.current = {};\r\n        schemaErrorsRef.current = {};\r\n        touchedFieldsRef.current = new Set();\r\n        watchFieldsRef.current = {};\r\n        dirtyFieldsRef.current = new Set();\r\n        fieldsWithValidationRef.current = new Set();\r\n        validFieldsRef.current = new Set();\r\n        defaultValuesRef.current = {};\r\n        isWatchAllRef.current = false;\r\n        isSubmittedRef.current = false;\r\n        isDirtyRef.current = false;\r\n        isSchemaValidateTriggeredRef.current = false;\r\n    };\r\n    const reset = useCallback((values) => {\r\n        const fieldsKeyValue = Object.entries(fieldsRef.current);\r\n        for (let [, value] of fieldsKeyValue) {\r\n            if (value && value.ref && value.ref.closest) {\r\n                try {\r\n                    value.ref.closest('form').reset();\r\n                    break;\r\n                }\r\n                catch (_a) { }\r\n            }\r\n        }\r\n        resetRefs();\r\n        if (values) {\r\n            fieldsKeyValue.forEach(([key]) => setFieldValue(key, getDefaultValue(values, key)));\r\n            defaultValuesRef.current = Object.assign({}, values);\r\n        }\r\n        submitCountRef.current = 0;\r\n        render({});\r\n    }, []);\r\n    const getValues = (payload) => {\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const output = payload && payload.nest ? combineFieldValues(fieldValues) : fieldValues;\r\n        return isEmptyObject(output) ? defaultValues : output;\r\n    };\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeEventListenerAndRef(field, true));\r\n    }, [removeEventListenerAndRef]);\r\n    return {\r\n        register: useCallback(register, [registerIntoFieldsRef]),\r\n        unregister: useCallback(unregister, [\r\n            unregister,\r\n            removeEventListenerAndRef,\r\n        ]),\r\n        handleSubmit,\r\n        watch,\r\n        reset,\r\n        clearError,\r\n        setError,\r\n        setValue,\r\n        triggerValidation,\r\n        getValues,\r\n        errors: validationFields\r\n            ? pickErrors(errorsRef.current, validationFields)\r\n            : errorsRef.current,\r\n        formState: Object.assign({ dirty: isDirtyRef.current, isSubmitted: isSubmittedRef.current, submitCount: submitCountRef.current, touched: [...touchedFieldsRef.current], isSubmitting: isSubmittingRef.current }, (isOnSubmit\r\n            ? {\r\n                isValid: isEmptyObject(errorsRef.current),\r\n            }\r\n            : {\r\n                isValid: validationSchema\r\n                    ? isSchemaValidateTriggeredRef.current &&\r\n                        isEmptyObject(schemaErrorsRef.current)\r\n                    : fieldsWithValidationRef.current.size\r\n                        ? !isEmptyObject(fieldsRef.current) &&\r\n                            validFieldsRef.current.size >=\r\n                                fieldsWithValidationRef.current.size\r\n                        : !isEmptyObject(fieldsRef.current),\r\n            })),\r\n    };\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormGlobalContext = createContext(null);\r\nfunction useFormContext() {\r\n    return useContext(FormGlobalContext);\r\n}\r\nfunction FormContext(props) {\r\n    const { children, formState, errors } = props, restMethods = __rest(props, [\"children\", \"formState\", \"errors\"]);\r\n    const restRef = useRef(restMethods);\r\n    return (createElement(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restRef.current), { formState, errors }) }, children));\r\n}\n\nexport default useForm;\nexport { FormContext, useFormContext };\n"]},"metadata":{},"sourceType":"module"}